
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API documentation &#8212; PyPlr v1.0 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Developers" href="developers.html" />
    <link rel="prev" title="Example Protocols" href="examples.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-pyplr.pupil">
<span id="api-documentation"></span><h1>API documentation<a class="headerlink" href="#module-pyplr.pupil" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pyplr-pupil">
<h2>pyplr.pupil<a class="headerlink" href="#pyplr-pupil" title="Permalink to this headline">¶</a></h2>
<p>A module for interfacing with a Pupil Core eye tracker.</p>
<dl class="py class">
<dt id="pyplr.pupil.LightStamper">
<em class="property">class </em><code class="sig-prename descclassname">pyplr.pupil.</code><code class="sig-name descname">LightStamper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pupil</span></em>, <em class="sig-param"><span class="n">trigger</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">15</span></em>, <em class="sig-param"><span class="n">wait_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">subscription</span><span class="o">=</span><span class="default_value">'frame.world'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.LightStamper" title="Permalink to this definition">¶</a></dt>
<dd><p>A thread-bound class which uses the Pupil Core World Camera to detect the 
onset of a light and send an annotation (a.k.a ‘trigger’) to Pupil Capture 
with the associated Pupil timestamp. Useful for integrating with virtually
any light source. Supports extraction of PLRs and calculation of time-critical 
measures such as latency and time-to-peak consctriction. Inherits from 
threading.Thread and overrides the .run() method. Instantiate a few seconds 
before administering a light stimulus. Works very well with the following 
settings in Pupil Capture:</p>
<ol class="arabic simple">
<li><p>Resolution (320, 240) for eye and world</p></li>
<li><p>Frame rate 120 for eye and world</p></li>
<li><p>Auto Exposure mode - Manual Exposure - eye and world</p></li>
<li><p>Absolute exposure time 60 for world, 63 for eye</p></li>
<li><p>Frame publisher format - BGR</p></li>
</ol>
<p>label = ‘LIGHT_ON’
trigger = new_trigger(label)
threshold = 15
wait_time = 5.
lst = LightStamper(pupil, trigger, threshold, wait_time)
lst.start()</p>
<dl class="py method">
<dt id="pyplr.pupil.LightStamper.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.LightStamper.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override the threading.Thread.run() method with light detection code. 
This code works by keeping track of the two most recent frames from the 
World Camera. When the difference between the two is greater than
the given threshold, a trigger is sent via pupil remote with the 
timestamp corresponding to the most recent frame.</p>
<p>None.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pyplr.pupil.PupilCore">
<em class="property">class </em><code class="sig-prename descclassname">pyplr.pupil.</code><code class="sig-name descname">PupilCore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span><span class="o">=</span><span class="default_value">'127.0.0.1'</span></em>, <em class="sig-param"><span class="n">request_port</span><span class="o">=</span><span class="default_value">'50020'</span></em>, <em class="sig-param"><span class="n">pyplr_defaults</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.PupilCore" title="Permalink to this definition">¶</a></dt>
<dd><p>A Class for Pupil Core and the remote helper.</p>
<dl class="py method">
<dt id="pyplr.pupil.PupilCore.command">
<code class="sig-name descname">command</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cmd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.PupilCore.command" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a command via Pupil Remote.</p>
<dl>
<dt>cmd<span class="classifier">string</span></dt><dd><p>Must be one of the following:</p>
<p>‘R’          - start recording with auto generated session name
‘R rec_name’ - start recording named “rec_name” 
‘r’          - stop recording
‘C’          - start currently selected calibration
‘c’          - stop currently selected calibration
‘T 1234.56’  - resets current Pupil time to given timestamp
‘t’          - get current Pupil time; returns a float as string
‘v’          - get the Pupil Core software version string
‘PUB_PORT’   - return the current pub port of the IPC Backbone 
‘SUB_PORT’   - return the current sub port of the IPC Backbone</p>
</dd>
</dl>
<dl class="simple">
<dt>string</dt><dd><p>the result of the command. If the command was not acceptable, this
will be ‘Unknown command.’</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.pupil.PupilCore.notify">
<code class="sig-name descname">notify</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">notification</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.PupilCore.notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a notification to Pupil Remote. Every notification has a topic 
and can contain potential payload data. The payload data has to be 
serializable, so not every Python object will work. To find out which
plugins send and receive notifications, open the codebase and search 
for <cite>.notify_all(</cite> and <cite>def on_notify(</cite>.</p>
<dl class="simple">
<dt>pupil_remote<span class="classifier">zmq.sugar.socket.Socket</span></dt><dd><p>the pupil remote helper.</p>
</dd>
<dt>notification<span class="classifier">dict</span></dt><dd><p>the notification dict. Some examples:</p>
<ul class="simple">
<li><p>{‘subject’: ‘start_plugin’, ‘name’: ‘Annotation_Capture’, ‘args’: {}})</p></li>
<li><p>{‘subject’: ‘recording.should_start’, ‘session_name’: ‘my session’}</p></li>
<li><p>{‘subject’: ‘recording.should_stop’}</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>string</dt><dd><p>the response.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.pupil.PupilCore.send_trigger">
<code class="sig-name descname">send_trigger</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">trigger</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.PupilCore.send_trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an annotation (a.k.a ‘trigger’) to Pupil Capture. Use to mark the 
timing of events.</p>
<dl class="simple">
<dt>trigger<span class="classifier">dict</span></dt><dd><p>customiseable - see the new_trigger(…) function.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pyplr.pupil.PupilGrabber">
<em class="property">class </em><code class="sig-prename descclassname">pyplr.pupil.</code><code class="sig-name descname">PupilGrabber</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pupil</span></em>, <em class="sig-param"><span class="n">topic</span></em>, <em class="sig-param"><span class="n">secs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.PupilGrabber" title="Permalink to this definition">¶</a></dt>
<dd><p>A thread-bound class for grabbing data from Pupil Core.</p>
<p>pupil = PupilCore()
pg = PupilGrabber(pupil, topic=’pupil.0.3d’, secs=10)
pg.start()</p>
<dl class="py method">
<dt id="pyplr.pupil.PupilGrabber.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">what</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.PupilGrabber.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get grabbed data.</p>
<dl class="simple">
<dt>what<span class="classifier">string</span></dt><dd><p>The key of the data to be accessed. E.g. ‘diameter_3d’, ‘timestamp’,
‘gaze_point_3d’.</p>
</dd>
</dl>
<dl class="simple">
<dt>np.array()</dt><dd><p>The requested data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.pupil.PupilGrabber.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.PupilGrabber.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override the threading.Thread.run() method with code for grabbing data.</p>
<p>None.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyplr.pupil.new_trigger">
<code class="sig-prename descclassname">pyplr.pupil.</code><code class="sig-name descname">new_trigger</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">label</span></em>, <em class="sig-param"><span class="n">custom_fields</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.new_trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new trigger / annotation / message / event marker / whatever 
you want to call it. Send it to Pupil Capture with the send_trigger(…) 
function.</p>
<dl class="simple">
<dt>label<span class="classifier">string</span></dt><dd><p>A label for the event.</p>
</dd>
<dt>custom_fields<span class="classifier">dict, optional</span></dt><dd><p>Any additional information to add (e.g. {‘duration’:2, ‘color’:’blue’}). 
The default is {}.</p>
</dd>
</dl>
<dl class="simple">
<dt>trigger<span class="classifier">dict</span></dt><dd><p>The trigger dictionary, ready to be sent.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pupil.notify">
<code class="sig-prename descclassname">pyplr.pupil.</code><code class="sig-name descname">notify</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pupil_remote</span></em>, <em class="sig-param"><span class="n">notification</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a notification to Pupil Remote.</p>
<dl class="simple">
<dt>pupil_remote<span class="classifier">zmq.sugar.socket.Socket</span></dt><dd><p>the pupil remote helper.</p>
</dd>
<dt>notification<span class="classifier">dict</span></dt><dd><p>the notification dict. 
e.g. {‘subject’:’start_plugin’, ‘name’:’Annotation_Capture’}</p>
</dd>
</dl>
<dl class="simple">
<dt>string</dt><dd><p>the response.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pupil.recv_from_subscriber">
<code class="sig-prename descclassname">pyplr.pupil.</code><code class="sig-name descname">recv_from_subscriber</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">subscriber</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.recv_from_subscriber" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a message with topic and payload.</p>
<dl class="simple">
<dt>subscriber<span class="classifier">zmq.sugar.socket.Socket</span></dt><dd><p>a subscriber to any valid topic.</p>
</dd>
</dl>
<dl>
<dt>topic<span class="classifier">str</span></dt><dd><p>A utf-8 encoded string, returned as a unicode object.</p>
</dd>
<dt>payload<span class="classifier">dict</span></dt><dd><p>A msgpack serialized dictionary, returned as a python dictionary.
Any addional message frames will be added as a list in the payload 
dictionary with key: ‘__raw_data__’. To use frame data, say: 
np.frombuffer(msg[‘__raw_data__’][0], dtype=np.uint8).reshape(</p>
<blockquote>
<div><p>msg[‘height’], msg[‘width’], 3)</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pupil.send_trigger">
<code class="sig-prename descclassname">pyplr.pupil.</code><code class="sig-name descname">send_trigger</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pub_socket</span></em>, <em class="sig-param"><span class="n">trigger</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pupil.send_trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an annotation (a.k.a ‘trigger’) to Pupil Capture. Use to mark the 
timing of events.</p>
<dl class="simple">
<dt>pub_socket<span class="classifier">zmq.sugar.socket.Socket</span></dt><dd><p>a socket to publish the trigger.</p>
</dd>
<dt>trigger<span class="classifier">dict</span></dt><dd><p>customiseable - see the new_trigger(…) function.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

</div>
<span class="target" id="module-pyplr.stlab"></span><div class="section" id="pyplr-stlab">
<h2>pyplr.stlab<a class="headerlink" href="#pyplr-stlab" title="Permalink to this headline">¶</a></h2>
<p>A python wrapper for Ledmotive’s Spectra Tune Lab light engine and RESTful API.
Also contains other useful functions for working with STLAB. See the “LIGHT HUB 
RESTful API” manual for further functions and more info. Note that a license is 
required to develop against the RESTful API.</p>
<dl class="py class">
<dt id="pyplr.stlab.CalibrationContext">
<em class="property">class </em><code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">CalibrationContext</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.CalibrationContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a calibration context based on spectrometer measurements. Currently 
this requires the measurements to be for each LED in steps of 65.</p>
<dl class="py method">
<dt id="pyplr.stlab.CalibrationContext.create_lookup_table">
<code class="sig-name descname">create_lookup_table</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.CalibrationContext.create_lookup_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a lookup table from original measurements using linear 
interpolation.</p>
<dl class="simple">
<dt>intp_tbl<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.CalibrationContext.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match_led</span></em>, <em class="sig-param"><span class="n">match_led_intensity</span></em>, <em class="sig-param"><span class="n">target_led</span></em>, <em class="sig-param"><span class="n">match_type</span><span class="o">=</span><span class="default_value">'irrad'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.CalibrationContext.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the appropriate intensity setting for target_led so that its 
output will match tmatch_led at match_led_intensity in terms of 
match_type.</p>
<dl>
<dt>match_led<span class="classifier">int</span></dt><dd><p>The led to be matched.</p>
</dd>
<dt>match_led_intensity<span class="classifier">int</span></dt><dd><p>The intensity of the led to be matched.</p>
</dd>
<dt>target_led<span class="classifier">int</span></dt><dd><p>The led whose intensity is to be determined.</p>
</dd>
<dt>match_type<span class="classifier">str, optional</span></dt><dd><p>The type of match to be performed. One of:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘irrad’ - overall (unweighted) irradiance</p></li>
<li><p>‘lux’   - lux</p></li>
<li><p>‘mel’   - melanopic irradiance</p></li>
<li><p>‘rhod’  - rhodopic irradiance</p></li>
<li><p>‘s’     - s-cone-opic irradiance</p></li>
<li><p>‘m’     - m-cone-opic irradiance</p></li>
<li><p>‘l’     - l-cone-opic irradiance</p></li>
</ul>
</div></blockquote>
<p>The default is ‘irrad’.</p>
</dd>
</dl>
<dl class="simple">
<dt>error<span class="classifier">float</span></dt><dd><p>The absolute matching error.</p>
</dd>
<dt>match_intensity<span class="classifier">int</span></dt><dd><p>The required intensity for match_led.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.CalibrationContext.plot_calibrated_spectra">
<code class="sig-name descname">plot_calibrated_spectra</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.CalibrationContext.plot_calibrated_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the ca;ibrated spectra.</p>
<dl class="simple">
<dt>fig<span class="classifier">Matplotlib Figure</span></dt><dd><p>The plot.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.CalibrationContext.predict_spd">
<code class="sig-name descname">predict_spd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">intensities</span><span class="o">=</span><span class="default_value">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.CalibrationContext.predict_spd" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the spectral power distribution for a given list of led 
intensities using linear interpolation.</p>
<dl class="simple">
<dt>intensity<span class="classifier">list</span></dt><dd><p>List of intensity values for each led. The default is 
[0,0,0,0,0,0,0,0,0,0].</p>
</dd>
<dt>lkp_table<span class="classifier">DataFrame</span></dt><dd><p>A wide-format DataFrame with hierarchichal pd.MultIndex 
[led, intensity] and a column for each of 81 5-nm wavelength bins. 
4096*10 rows, containing predicted output for each led at all
possible intensities.</p>
</dd>
</dl>
<dl class="simple">
<dt>spectrum<span class="classifier">np.array</span></dt><dd><p>Predicted spectrum for given intensities.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pyplr.stlab.SpectraTuneLab">
<em class="property">class </em><code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">SpectraTuneLab</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">username</span></em>, <em class="sig-param"><span class="n">identity</span></em>, <em class="sig-param"><span class="n">password</span></em>, <em class="sig-param"><span class="n">lighthub_ip</span><span class="o">=</span><span class="default_value">'192.168.7.2'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to encapsulate the LEDMOTIVE Spectra Tune Lab device and its 
RESTFUL_API.</p>
<dl class="simple">
<dt>description<span class="classifier">string</span></dt><dd><p>A description of the device.</p>
</dd>
<dt>colors<span class="classifier">string</span></dt><dd><p>Closest Matplotlib colornames for the 10 channels.</p>
</dd>
<dt>rgb_colors<span class="classifier">list</span></dt><dd><p>rgb colors of the 10 channels taken from photographs</p>
</dd>
<dt>wlbins<span class="classifier">list</span></dt><dd><p>The wavelengths output by the on-board spectrometer</p>
</dd>
<dt>min_intensity<span class="classifier">int</span></dt><dd><p>The minimum intensity setting for LEDs</p>
</dd>
<dt>max_intensity<span class="classifier">int</span></dt><dd><p>The maximum intensity setting for the LEDs</p>
</dd>
</dl>
<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.color_xy">
<code class="sig-name descname">color_xy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">intensity_values</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.color_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to the ‘spectruma’ command, but allows setting a target x, y
coordinates in the CIE1931 color space.</p>
<dl class="simple">
<dt>intensity_values<span class="classifier">list</span></dt><dd><p>the desired spectrum as a list of integers.</p>
</dd>
<dt>x<span class="classifier">float</span></dt><dd><p>desired target CIE1931 x coordinate as a decimal number.</p>
</dd>
<dt>y<span class="classifier">float</span></dt><dd><p>desired target CIE1931 y coordinate as a decimal number.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.full_readout">
<code class="sig-name descname">full_readout</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">setting</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.full_readout" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a full readout from the STLAB.</p>
<dl class="simple">
<dt>setting<span class="classifier">dict, optional</span></dt><dd><p>The current setting of the luminaire (if known), to be included in
the info_dict. For example {‘led’ : 5, ‘intensity’ : 3000}, or 
{‘intensities’ : [0, 0, 0, 300, 4000, 200, 0, 0, 0, 0]}. 
The default is {}.</p>
</dd>
</dl>
<dl class="simple">
<dt>counts<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt>info_dict<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.get_colour_priority">
<code class="sig-name descname">get_colour_priority</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.get_colour_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current color priority configuration for this luminaire.</p>
<dl class="simple">
<dt>colour_priority<span class="classifier">bool</span></dt><dd><p>Whether colour priority is enabled.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.get_device_info">
<code class="sig-name descname">get_device_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.get_device_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the device characteristics and basic configuration. These are 
the serial code, the model code, the number of channels for this 
luminaire and the device feedback type (whether it is colorimeter or 
spectrometer). How are the serial and model codes is yet to be defined,
but we expect a maximum 50 character length code for serial and 30 for
model.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.get_input_power">
<code class="sig-name descname">get_input_power</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.get_input_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current consumed electrical power of the luminaire in mW.</p>
<dl class="simple">
<dt>input_power<span class="classifier">int</span></dt><dd><p>The electrical power at the luminaire in mW..</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.get_led_calibration">
<code class="sig-name descname">get_led_calibration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.get_led_calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current LED calibration matrix containing 10 rows 
(for each channel) and 81 columns (intensity value from 380 to 780 nm 
in steps of 5 nm).</p>
<p>None.</p>
<dl class="simple">
<dt>matrix<span class="classifier">list</span></dt><dd><p>10 x 81 calibration matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.get_pcb_temperature">
<code class="sig-name descname">get_pcb_temperature</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.get_pcb_temperature" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the PCB temperature in Celsius degrees (ºC). Returns a list of 
4 elements in this order: LEDs, Drivers, Spectrometer and Microcontroller 
temperature sensors close to these elements. If one sensor or its readout 
is not available a null value is returned for that element.</p>
<p>None.</p>
<dl class="simple">
<dt>temperatures<span class="classifier">np.array</span></dt><dd><p>[  Number,  Number,  Number,  Number  ].</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.get_spectrometer_integration_time">
<code class="sig-name descname">get_spectrometer_integration_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.get_spectrometer_integration_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current integration time used by the spectrometer for gathering data.</p>
<dl class="simple">
<dt>integration_time<span class="classifier">int</span></dt><dd><p>A positive integer ranging from 50 to 140000 in tenths of millisecond.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.get_spectrometer_spectrum">
<code class="sig-name descname">get_spectrometer_spectrum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norm</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.get_spectrometer_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the spectrum readout from the internal spectrometer. If the
luminaire does only contain a colorimeter sensor, a theoretical spectrum 
based on the current channels power is obtained instead. 
The data is returned in 81 elements that represents a 5 nm wavelength 
bins from 380 nm to 780 nm. Each element is a value ranging from 0 to 
65535 abstracting the light intensity at each point and allowing the 
reconstruction of the spectral shape. An additional element represents
the radiometric value in milliWatts (mW) at the peak of a max value of 
a spectrum at which the abstracted values are normalized, i.e. the flux
corresponding to a 65535 value in the array. This flux depends on multiple
factors, as current channels power, dimming level, power protection and 
maximum power of the lighted LEDs.</p>
<dl class="simple">
<dt>norm<span class="classifier">bool, optional</span></dt><dd><p>whether to normalize the spectrum to its peak radiometric value</p>
</dd>
</dl>
<dl class="simple">
<dt>spectrum<span class="classifier">list</span></dt><dd><p>[Number, Number, …, Number, Number] with 81 elements</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.get_spectrum_a">
<code class="sig-name descname">get_spectrum_a</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.get_spectrum_a" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current amplitude for each of the luminaire channels. The 
array returned has a length equal to the channel count of the luminaire. 
Each value in the array is a representation of electrical counts, 
ranging from 0 to 4095 counts.</p>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.load_video_file">
<code class="sig-name descname">load_video_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fname</span></em>, <em class="sig-param"><span class="n">return_vf_dict</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.load_video_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Uploads a video light sequence file to the LIGHT HUB. The video file 
must follow the LEDMOTIVE Dynamic Sequence File (.dsf) format. The 
uploaded file must be a json file (.dsf files are json files), and 
weight less than 2 MB. The file must be uploaded using the multipart / 
form-data standard convention. See play_video_file later about how 
to play the uploaded file in a luminaire.</p>
<dl class="simple">
<dt>video<span class="classifier">string</span></dt><dd><p>name of the video file.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.play_video_file">
<code class="sig-name descname">play_video_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stop</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.play_video_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts the execution of a light video sequence in the specified luminaire
or multicast address. If no video is in the LIGHT HUB, an error response
is raised, and the command ignored. If the video is already playing, the 
play is interrupted, and the video is reproduced back from the beginning. 
To stop the video, set ‘stop’ to True. See load_video_file for how to
load a video file.</p>
<dl class="simple">
<dt>stop<span class="classifier">bool, optional</span></dt><dd><p>whether the command should stop the video. The default is False.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">leds</span><span class="o">=</span><span class="default_value">[0]</span></em>, <em class="sig-param"><span class="n">intensities</span><span class="o">=</span><span class="default_value">[500]</span></em>, <em class="sig-param"><span class="n">spectra</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wait_before_sample</span><span class="o">=</span><span class="default_value">0.3</span></em>, <em class="sig-param"><span class="n">ocean_optics</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ocean_optics_inegration_times</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">randomise</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">save_output</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">settings_override</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a set of LEDs individually at a range of specified intensities 
using the STLABs on-board spectrometer. Or, alternatively, sample a set
of pre-defined spectra. Option to also obtain concurrent measurements 
with an external Ocean Optics spectrometer.</p>
<dl class="simple">
<dt>leds<span class="classifier">list, optional</span></dt><dd><p>List of unique integers from 0-9 representing the LEDs to sample.
The default is [0].</p>
</dd>
<dt>intensities<span class="classifier">list, optional</span></dt><dd><p>List of integer values between 0-4095 representing the intensity 
values at which to sample the LEDs. The default is [500].</p>
</dd>
<dt>spectra<span class="classifier">list, optinal</span></dt><dd><p>List of predfined spectra to sample. Must be None if specifying
leds or intensities. The default is None.</p>
</dd>
<dt>wait_before_sample<span class="classifier">float, optional</span></dt><dd><p>Time in seconds to wait after setting a spectrum before acquiring 
a measurement from the spectrometer(s). The default is .2.</p>
</dd>
<dt>ocean_optics<span class="classifier">seabreeze.spectrometers.Spectrometer, optional</span></dt><dd><p>Whether to acquire concurrent measurements from an Ocean Optics 
spectrometer. Requires the seabreeze package to be installed.
The default is None.</p>
</dd>
<dt>ocean_optics_inegration_times<span class="classifier">pd.DataFrame</span></dt><dd><p>STUFF</p>
</dd>
<dt>randomise<span class="classifier">bool, optional</span></dt><dd><p>Whether to randomise the order in which the LED-intensity settings 
or spectra are sampled. The default is False.</p>
</dd>
<dt>save_output<span class="classifier">bool, optional</span></dt><dd><p>Whether to save the samples and info as .csv files in the current
working directory.</p>
</dd>
</dl>
<dl class="simple">
<dt>stlab_spectra<span class="classifier">pd.DataFrame</span></dt><dd><p>The resulting measurements from the STLAB spectrometer.</p>
</dd>
<dt>stlab_info<span class="classifier">pd.DataFrame</span></dt><dd><p>The companion info to stlab_spectra, with matching indices.</p>
</dd>
<dt>oo_spectra<span class="classifier">pd.DataFrame, optional</span></dt><dd><p>The resulting measurements from the Ocean Optics spectrometer.</p>
</dd>
<dt>oo_info<span class="classifier">pd.DataFrame, optional</span></dt><dd><p>The companion info to the oo_spectra, with matching indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.set_blink">
<code class="sig-name descname">set_blink</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">blink</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.set_blink" title="Permalink to this definition">¶</a></dt>
<dd><p>Commands the luminaire to blink. The value provided as an argument is the
number of times the light blinks in one second.</p>
<dl class="simple">
<dt>blink<span class="classifier">int, optional</span></dt><dd><p>number of times the light should blink in one second. The default is 1.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.set_color">
<code class="sig-name descname">set_color</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">flux</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.set_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a light color represented in the CIE1931 color space. The x and y
coordinates are the mathematical index that represents the target color to 
be achieved. If the x,y provided values are not available by the system, 
it will find its nearest available x,y coordinates. If flux is provided as
an argument, it will be adjusted automatically, otherwise the current flux 
will be used.</p>
<dl class="simple">
<dt>x<span class="classifier">float</span></dt><dd><p>desired target CIE1931 x coordinate as a decimal number.</p>
</dd>
<dt>y<span class="classifier">float</span></dt><dd><p>desired target CIE1931 y coordinate as a decimal number.</p>
</dd>
<dt>flux<span class="classifier">int, optional</span></dt><dd><p>value between 0 and 4095. The default is None.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.set_colour_priority">
<code class="sig-name descname">set_colour_priority</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">colour_priority</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.set_colour_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Command the luminaire to always first approximate to the desired color 
of the spectrum to set before setting the spectrum channel values. 
This function is set to true or false (enabled or disabled).</p>
<dl class="simple">
<dt>colour_priority<span class="classifier">bool</span></dt><dd><p>whether to enable or disable colour priority</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.set_dimming_level">
<code class="sig-name descname">set_dimming_level</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dimming_level</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.set_dimming_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets an intensity dimmer. This percentage modulates the current intensity 
by multiplying the power count of each luminaire channel, i.e. if you 
send a spectrum where each channel count is at half level and the dimming 
is set at 50%, the final light intensity will be one quarter of the 
luminaire full capacity.</p>
<dl class="simple">
<dt>dimming_level<span class="classifier">int</span></dt><dd><p>Percentage dimming level.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.set_spectrometer_integration_time">
<code class="sig-name descname">set_spectrometer_integration_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">integration_time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.set_spectrometer_integration_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the integration time of the spectrometer to gather data. Longer 
times will result in more light reaching the sensor (like exposure 
time in photography). Special attention should be taken to avoid 
signal saturation.</p>
<dl class="simple">
<dt>integration_time<span class="classifier">int</span></dt><dd><p>A positive integer ranging from 50 to 140000 in tenths of millisecond.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.set_spectrum_a">
<code class="sig-name descname">set_spectrum_a</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">intensity_values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.set_spectrum_a" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a spectrum based on the intensity values provided for each of the 
channels. Each channel can be set between 0 and 4095 (only integer values).</p>
<dl class="simple">
<dt>intensity_values<span class="classifier">list</span></dt><dd><p>list of 10 integer values between 0 and 4095</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.set_spectrum_s">
<code class="sig-name descname">set_spectrum_s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectrum</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.set_spectrum_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the given spectrum. The spectrum is defined by an array of 
81 elements that represents 5 nm wavelength bins from 380 nm to 780 nm.
The values are an abstraction of the light intensity at each point 
that allows the reconstruction of the spectrum shape. Each value ranges 
between 0 and 65535, being 0 no intensity and 65535 full intensity at 
the corresponding wavelength bin (prior application of dimming and 
power protection caps).</p>
<dl class="simple">
<dt>spectrum<span class="classifier">list</span></dt><dd><p>list of 81 (the 380 nm to 780 nm bins) integer values between 
0 and 65535.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.spectruma">
<code class="sig-name descname">spectruma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">intensity_values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.spectruma" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a spectrum based on the intensity values provided for each of
the channels. Each channel can be set between 0 and 4095. This is an 
alternative way to the command SET_SPECTRUM_A that allows setting a 
spectrum issuing a GET command (which allows access to the luminaire by
typing a url in any browser).</p>
<dl class="simple">
<dt>intensity_values<span class="classifier">list</span></dt><dd><p>list of 10 integer values between 0 and 4095.</p>
</dd>
</dl>
<p>None.</p>
</dd></dl>

<dl class="py method">
<dt id="pyplr.stlab.SpectraTuneLab.turn_off">
<code class="sig-name descname">turn_off</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.SpectraTuneLab.turn_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops light emission by setting the power at all channels to 0.</p>
<p>None.</p>
<p>None.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.background_pulse_protocol">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">background_pulse_protocol</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">background_spec</span></em>, <em class="sig-param"><span class="n">pre_pulse_duration</span></em>, <em class="sig-param"><span class="n">pulse_spec</span></em>, <em class="sig-param"><span class="n">pulse_duration</span></em>, <em class="sig-param"><span class="n">post_pulse_duration</span></em>, <em class="sig-param"><span class="n">fname</span><span class="o">=</span><span class="default_value">'our_video_file'</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">metadata</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.background_pulse_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a video file to deliver a pulse of light (or dark) against a 
background of light (or dark). Clunky but works well.</p>
<dl class="simple">
<dt>background_spec<span class="classifier">list</span></dt><dd><p>The background spectrum.</p>
</dd>
<dt>pre_pulse_duration<span class="classifier">int</span></dt><dd><p>Duration of the background prior to pulse.</p>
</dd>
<dt>pulse_spec<span class="classifier">list</span></dt><dd><p>The pulse spectrum..</p>
</dd>
<dt>pulse_duration<span class="classifier">int</span></dt><dd><p>Duration of the pulse in ms.</p>
</dd>
<dt>post_pulse_duration<span class="classifier">int</span></dt><dd><p>Duration of the background after the pulse..</p>
</dd>
<dt>fname<span class="classifier">str, optional</span></dt><dd><p>Name for the video file. The default is ‘our_video_file’.</p>
</dd>
<dt>return_df<span class="classifier">bool, optional</span></dt><dd><p>Whether to return the DataFrame. The default is False.</p>
</dd>
<dt>metadata<span class="classifier">dict</span></dt><dd><p>Additional info to include in the metadata field of the video file 
(e.g. {‘color’ : ‘blue’}). This info can be extracted when loading the 
file during an experiment and included in triggers sent to Pupil Capture.
The default is {}.</p>
</dd>
</dl>
<dl class="simple">
<dt>df<span class="classifier">pd.DataFrame</span></dt><dd><p>The DataFrame passed to make_video_file (if requested).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.explore_spectra">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">explore_spectra</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectra</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.explore_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes a DataFrame of spectra and plots them, along with other
useful info.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.interp_spectra">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">interp_spectra</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectra</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.interp_spectra" title="Permalink to this definition">¶</a></dt>
<dd><p>This function needs generalising.</p>
<dl class="simple">
<dt>spectra<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
</dl>
<dl class="simple">
<dt>intp_tbl<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.make_video_file">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">make_video_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">fname</span><span class="o">=</span><span class="default_value">'our_video_file'</span></em>, <em class="sig-param"><span class="n">repeats</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">metadata</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.make_video_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a DataFrame with columns ‘time’, ‘LED-1’…’LED-10’
and save it as a .dsf (‘dynamic sequence file’) in the current
working directory. The .dsf file can be loaded and played as a video stream
with the STLAB.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.predict_spd">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">predict_spd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">intensity</span><span class="o">=</span><span class="default_value">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></em>, <em class="sig-param"><span class="n">lkp_table</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.predict_spd" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the spectral power distribution for a given list of led 
intensities using linear interpolation.</p>
<dl class="simple">
<dt>intensity<span class="classifier">list</span></dt><dd><p>List of intensity values for each led. The default is [0,0,0,0,0,0,0,0,0,0].</p>
</dd>
<dt>lkp_table<span class="classifier">DataFrame</span></dt><dd><p>A wide-format DataFrame with hierarchichal pd.MultIndex [led, intensity] 
and a column for each of 81 5-nm wavelength bins. 4096*10 rows, containing
predicted output for each led at all possible intensities.</p>
</dd>
</dl>
<dl class="simple">
<dt>spectrum<span class="classifier">np.array</span></dt><dd><p>Predicted spectrum for given intensities.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.pulse_protocol">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">pulse_protocol</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pulse_spec</span></em>, <em class="sig-param"><span class="n">pulse_duration</span></em>, <em class="sig-param"><span class="n">fname</span><span class="o">=</span><span class="default_value">'our_video_file'</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">metadata</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.pulse_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a video file to deliver a pulse of light.</p>
<dl class="simple">
<dt>spec<span class="classifier">list</span></dt><dd><p>Sprectrum to use for the pulse of light.</p>
</dd>
<dt>duration<span class="classifier">int</span></dt><dd><p>Duration of the pulse in ms.</p>
</dd>
<dt>video_name<span class="classifier">str</span></dt><dd><p>Name for the video file.</p>
</dd>
<dt>return_df<span class="classifier">bool</span></dt><dd><p>Whether to return the DataFrame used to create the video file.</p>
</dd>
<dt>metadata<span class="classifier">dict</span></dt><dd><p>Additional info to include in the metadata of the video file (e.g. 
‘color’ : ‘blue’).</p>
</dd>
</dl>
<dl class="simple">
<dt>df<span class="classifier">pd.DataFrame</span></dt><dd><p>The DataFrame passed to make_video_file (if requested).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.spec_to_xyz">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">spec_to_xyz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.spec_to_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a spectrum to an xyz point.</p>
<p>The spectrum must be on the same grid of points as the colour-matching
function, cmf: 380-780 nm in 5 nm steps.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.spectra_to_peak_wavelengths">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">spectra_to_peak_wavelengths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectra</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.spectra_to_peak_wavelengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the peak wavelengths for a given set of spectra.</p>
<dl class="simple">
<dt>spectra<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
</dl>
<dl class="simple">
<dt>pwl<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.spectra_to_xyz">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">spectra_to_xyz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectra</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.spectra_to_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the CIE 1931 xy chromaticity coordinates for a collection of
spectra. The DataFrame must have columns (or multi index) with names</p>
<dl class="simple">
<dt>spectra<span class="classifier">DataFrame</span></dt><dd><p>As output by stlab.sample_leds</p>
</dd>
</dl>
<dl class="simple">
<dt>xyz<span class="classifier">DataFrame</span></dt><dd><p>The xyz values for each spectrum.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.stlab.video_file_to_dict">
<code class="sig-prename descclassname">pyplr.stlab.</code><code class="sig-name descname">video_file_to_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">video_file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.stlab.video_file_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack a video file into a dictionary with keys [‘header’, ‘metadata’, 
‘spectra’, ‘transitions’]</p>
<dl class="simple">
<dt>video_file<span class="classifier">str</span></dt><dd><p>The video file to unpack.</p>
</dd>
</dl>
<dl class="simple">
<dt>data<span class="classifier">dict</span></dt><dd><p>the video file as a dictionary.</p>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-pyplr.CIE"></span><div class="section" id="pyplr-cie">
<h2>pyplr.CIE<a class="headerlink" href="#pyplr-cie" title="Permalink to this headline">¶</a></h2>
<p>Convenience functions for accessing CIE standards.</p>
<p>note:,https://scipython.com/blog/converting-a-spectrum-to-a-colour/
note: http://cvrl.ioo.ucl.ac.uk/cmfs.htm</p>
<dl class="py function">
<dt id="pyplr.CIE.get_CIE_CMF">
<code class="sig-prename descclassname">pyplr.CIE.</code><code class="sig-name descname">get_CIE_CMF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">asdf</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.CIE.get_CIE_CMF" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the CIE color matching functions as a numpy array or pandas DataFrame.</p>
<dl class="simple">
<dt>asdf<span class="classifier">bool, optional</span></dt><dd><p>Return as a pandas DataFrame. The default is False.</p>
</dd>
</dl>
<dl class="simple">
<dt>cmf<span class="classifier">np.array</span></dt><dd><p>The CIE CMFs.</p>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-pyplr.plr"></span><div class="section" id="pyplr-plr">
<h2>pyplr.plr<a class="headerlink" href="#pyplr-plr" title="Permalink to this headline">¶</a></h2>
<p>A module to assist with parametrising and plotting pupillary light reflexes.</p>
<dl class="py function">
<dt id="pyplr.plr.acceleration_profile">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">acceleration_profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.acceleration_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the acceleration profile of a PLR.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.average_constriction_velocity">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">average_constriction_velocity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em>, <em class="sig-param"><span class="n">pc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.average_constriction_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average constriction velocity.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.baseline">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">baseline</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.baseline" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average pupil size between the start of s and onset_idx</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.constriction_amplitude">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">constriction_amplitude</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.constriction_amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the constriction amplitude (i.e. the absolute difference 
between baseline and peak constriction).</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.constriction_time">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">constriction_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em>, <em class="sig-param"><span class="n">pc</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.constriction_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the time difference between constriction latency and peak constriction.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.latency_idx">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">latency_idx</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em>, <em class="sig-param"><span class="n">pc</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.latency_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the first sample following stimulus onset where 
constriction exceeds a percentage of the baseline. pc should be int or
float for data already expressed as pc (e.g. pc=1 == pc=.01).</p>
<p>FIGURE OUT A BETTER WAY OF DOING THIS.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.latency_to_constriction_a">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">latency_to_constriction_a</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em>, <em class="sig-param"><span class="n">pc</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.latency_to_constriction_a" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the time in miliseconds between stimulus onset and the first 
sample where constriction exceeds a percentage of the baseline.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.latency_to_constriction_b">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">latency_to_constriction_b</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.latency_to_constriction_b" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the time in miliseconds between stimulus onset and the time 
at which the pupil reaches maximal negative acceleration within a 
1-s window. See Bergamin &amp; Kardon (2003) for justification. Requires 
well-smoothed pupil data.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.max_constriction_acceleration">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">max_constriction_acceleration</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.max_constriction_acceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum constriction acceleration.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.max_constriction_velocity">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">max_constriction_velocity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.max_constriction_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum constriction velocity.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.max_redilation_acceleration">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">max_redilation_acceleration</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.max_redilation_acceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum redilation acceleration.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.max_redilation_velocity">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">max_redilation_velocity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.max_redilation_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum redilation velocity.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.peak_constriction">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">peak_constriction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.peak_constriction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the peak constriction value (i.e. the smallest pupil size).</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.peak_constriction_idx">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">peak_constriction_idx</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.peak_constriction_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the sample with peak constriction.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.pipr_AUC_early">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">pipr_AUC_early</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em>, <em class="sig-param"><span class="n">duration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.pipr_AUC_early" title="Permalink to this definition">¶</a></dt>
<dd><p>Unitless - AUC between offset and 10 s post offset</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.pipr_AUC_late">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">pipr_AUC_late</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em>, <em class="sig-param"><span class="n">duration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.pipr_AUC_late" title="Permalink to this definition">¶</a></dt>
<dd><p>Unitless - AUC between 10-30 s post offset</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.pipr_duration">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">pipr_duration</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em>, <em class="sig-param"><span class="n">duration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.pipr_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the time to return to baseline after light offset. ISI should be 
between 100 and 660 s to allow pupil to return to baseline (see Adhikari
et al., 2015)</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.plot_plr">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">plot_plr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em>, <em class="sig-param"><span class="n">stim_dur</span></em>, <em class="sig-param"><span class="n">vel_acc</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">stamp_params</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.plot_plr" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a PLR with option to add descriptive parameters and 
velocity / acceleration profiles. Useful for exploratory analysis.</p>
<dl class="simple">
<dt>s<span class="classifier">pd.Series</span></dt><dd><p>data representing a pupil’s response to light.</p>
</dd>
<dt>sample_rate<span class="classifier">int</span></dt><dd><p>sampling rate of the measurement system.</p>
</dd>
<dt>onset_idx<span class="classifier">int</span></dt><dd><p>index of the onset of the light stimulus.</p>
</dd>
<dt>stim_dur<span class="classifier">float</span></dt><dd><p>Duration (s) of the light stimulus.</p>
</dd>
<dt>vel_acc<span class="classifier">bool, optional</span></dt><dd><p>Whether to also plot the velocity and acceleration profiles.
The default is False.</p>
</dd>
<dt>stamp_metrics<span class="classifier">bool, optional</span></dt><dd><p>Whether to annotate the axis with the results of a call to 
plr_metrics(…). The default is False.</p>
</dd>
</dl>
<dl class="simple">
<dt>fig<span class="classifier">matplotlib.figure.Figure</span></dt><dd><p>the plot.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.plr_parameters">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">plr_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em>, <em class="sig-param"><span class="n">pc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.plr_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Collapse a PLR into descriptive parameters.</p>
<dl class="simple">
<dt>s<span class="classifier">array-like</span></dt><dd><p>data representing a pupil’s response to light.</p>
</dd>
<dt>sample_rate<span class="classifier">int</span></dt><dd><p>sampling rate of the measurement system.</p>
</dd>
<dt>onset_idx<span class="classifier">int</span></dt><dd><p>index of the onset of the light stimulus.</p>
</dd>
<dt>pc<span class="classifier">int, float</span></dt><dd><p>the percentage of constriction from baseline to use in calculating
constriction latency. Use float (e.g. pc=0.01) or int (e.g. pc=1)
for data already expressed as %-modulation from baseline.</p>
</dd>
</dl>
<dl class="simple">
<dt>params<span class="classifier">pd.DataFrame</span></dt><dd><p>DataFrame containins the params.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.recovery_time_75pc">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">recovery_time_75pc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.recovery_time_75pc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the time in ms until 75% recovery from baseline.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.time_to_max_constriction">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">time_to_max_constriction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.time_to_max_constriction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the time in miliseconds between stimulus onset and the peak 
of pupil constriction.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.time_to_max_velocity">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">time_to_max_velocity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">onset_idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.time_to_max_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the time between stimulus onset and when pupil constriction reaches 
maximum velocity.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.plr.velocity_profile">
<code class="sig-prename descclassname">pyplr.plr.</code><code class="sig-name descname">velocity_profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.plr.velocity_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the velocity profile of a PLR.</p>
</dd></dl>

</div>
<span class="target" id="module-pyplr.oceanops"></span><div class="section" id="pyplr-oceanops">
<h2>pyplr.oceanops<a class="headerlink" href="#pyplr-oceanops" title="Permalink to this headline">¶</a></h2>
<p>A module to help with measurents for Ocean Optics spectrometers.</p>
<dl class="py function">
<dt id="pyplr.oceanops.dark_measurement">
<code class="sig-prename descclassname">pyplr.oceanops.</code><code class="sig-name descname">dark_measurement</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectrometer</span></em>, <em class="sig-param"><span class="n">integration_times</span><span class="o">=</span><span class="default_value">[1000]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.oceanops.dark_measurement" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the dark spectrum with a range of integration times. Do this for a 
range of temperatures to characterise the relationship between temperature
and integration time.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.oceanops.oo_measurement">
<code class="sig-prename descclassname">pyplr.oceanops.</code><code class="sig-name descname">oo_measurement</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectrometer</span></em>, <em class="sig-param"><span class="n">integration_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">setting</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.oceanops.oo_measurement" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given light source, use an adaptive procedure to find the integration 
time which returns a spectrum whose maximum reported value in raw units is
between 80-90% of the maximum intensity value for the device. Can take up
to a maximum of ~3.5 mins for lower light levels, though this could be 
reduced somewhat by optimising the algorithm.</p>
<dl class="simple">
<dt>spectrometer<span class="classifier">seabreeze.spectrometers.Spectrometer</span></dt><dd><p>The Ocean Optics spectrometer instance.</p>
</dd>
<dt>integration_time<span class="classifier">int</span></dt><dd><p>The integration time to use for the measurement. Leave as None to
adaptively set the integration time based on spectral measurements.</p>
</dd>
<dt>setting<span class="classifier">dict, optional</span></dt><dd><p>The current setting of the light source (if known), to be included in
the info_dict. For example {‘led’ : 5, ‘intensity’ : 3000}, or 
{‘intensities’ : [0, 0, 0, 300, 4000, 200, 0, 0, 0, 0]}. 
The default is {}.</p>
</dd>
</dl>
<dl class="simple">
<dt>oo_spectra<span class="classifier">pd.DataFrame</span></dt><dd><p>The resulting measurements from the Ocean Optics spectrometer.</p>
</dd>
<dt>oo_info_dict<span class="classifier">dict</span></dt><dd><p>The companion info to the oo_spectra, with matching indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.oceanops.predict_dark_counts">
<code class="sig-prename descclassname">pyplr.oceanops.</code><code class="sig-name descname">predict_dark_counts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectra_info</span></em>, <em class="sig-param"><span class="n">darkcal</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.oceanops.predict_dark_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the dark counts from the temperature and integration times of a
set of measurements. These must be subtracted from measured pixel counts 
during the unit-calibration process.</p>
<dl class="simple">
<dt>spectra_info<span class="classifier">pd.DataFrame</span></dt><dd><p>The info dataframe containing the ‘board_temp’ and ‘integration_time’
variables.</p>
</dd>
<dt>calfile<span class="classifier">string</span></dt><dd><p>Path to the calibration file. This is currenly generated in MATLAB.</p>
</dd>
</dl>
<dl class="simple">
<dt>pd.DataFrame</dt><dd><p>The predicted dark spectra.</p>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-pyplr.pipeline"></span><div class="section" id="pyplr-pipeline">
<h2>pyplr.pipeline<a class="headerlink" href="#pyplr-pipeline" title="Permalink to this headline">¶</a></h2>
<p>Tools for implementing a pupillometry analysis pipeline.</p>
<dl class="py function">
<dt id="pyplr.pipeline.butterworth_series">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">butterworth_series</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">fields</span><span class="o">=</span><span class="default_value">['diameter']</span></em>, <em class="sig-param"><span class="n">filt_order</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">cutoff_freq</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.butterworth_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a butterworth filter to the given fields
See documentation on scipy’s butter method FMI.</p>
<p>The cutoff freq should be 4/(sample_rate/2)</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.ev_row_idxs">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">ev_row_idxs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">blinks</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.ev_row_idxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices in ‘samples’ contained in events from ‘events’.</p>
<dl class="simple">
<dt>samples<span class="classifier">DataFrame</span></dt><dd><p>The samples from which to pull indices.</p>
</dd>
<dt>events<span class="classifier">DataFrame</span></dt><dd><p>The events whose indices should be pulled from ‘samples’.</p>
</dd>
</dl>
<dl class="simple">
<dt>samps<span class="classifier">DataFrame</span></dt><dd><p>masked data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.even_samples">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">even_samples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samps</span></em>, <em class="sig-param"><span class="n">sample_rate</span></em>, <em class="sig-param"><span class="n">fields</span><span class="o">=</span><span class="default_value">['diameter']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.even_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the data in fields to a new index with evenly spaced timepoints
starting from 0 in steps of 1 / sample_rate.</p>
<dl class="simple">
<dt>samps<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt>sample_rate<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt>fields<span class="classifier">TYPE, optional</span></dt><dd><p>DESCRIPTION. The default is [‘diameter’].</p>
</dd>
</dl>
<dl class="simple">
<dt>samps<span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.extract">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">events</span></em>, <em class="sig-param"><span class="n">offset</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">duration</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">borrow_attributes</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts ranges from samples based on event timing and sample count.</p>
<dl class="simple">
<dt>samples<span class="classifier">DataFrame</span></dt><dd><p>The samples from which to extract events. Index must be timestamp.</p>
</dd>
<dt>events<span class="classifier">DataFrame</span></dt><dd><p>The events to extract. Index must be timestamp.</p>
</dd>
<dt>offset<span class="classifier">int, optional</span></dt><dd><p>Number of samples to offset from baseline. The default is 0.</p>
</dd>
<dt>duration<span class="classifier">int, optional</span></dt><dd><p>Duration of all events in terms of the number of samples. Currently 
this has to be the same for all events, but could use a ‘duration’ 
column in events DataFrame if needs be. The default is 0.</p>
</dd>
<dt>borrow_attributes<span class="classifier">list of str, optional</span></dt><dd><p>List of column names in the events DataFrame whose values should be
copied to the respective ranges. For each item in the list, a
column will be created in the ranges dataframe - if the column does
not exist in the events dataframe, the values in the each
corresponding range will be set to float(‘nan’). This is uesful for 
marking conditions, grouping variables, etc. The default is [].</p>
</dd>
</dl>
<dl class="simple">
<dt>df<span class="classifier">DataFrame</span></dt><dd><p>Extracted events complete with hierarchical multi-index.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.get_mask_idxs">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">get_mask_idxs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">blinks</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.get_mask_idxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds indices from ‘samples’ within the returned events.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.interpolate_blinks">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">interpolate_blinks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">blinks</span></em>, <em class="sig-param"><span class="n">fields</span><span class="o">=</span><span class="default_value">['diameter']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.interpolate_blinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs Pupil Labs eye blinks with linear interpolation.</p>
<dl class="simple">
<dt>samples<span class="classifier">DataFrame</span></dt><dd><p>Must contain at least ‘pupil_timestamp’ and ‘diameter’ columns</p>
</dd>
<dt>blinks<span class="classifier">DataFrame</span></dt><dd><p>Must contain ‘start_timestamp’ and ‘end_timestamp’ columns</p>
</dd>
<dt>interp_cols<span class="classifier">list, optional</span></dt><dd><p>Columns to interpolate. The default is [‘diameter’].</p>
</dd>
</dl>
<dl class="simple">
<dt>samps<span class="classifier">DataFrame</span></dt><dd><p>blink-interpolated data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.interpolate_pupil">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">interpolate_pupil</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">interp_cols</span><span class="o">=</span><span class="default_value">['diameter']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.interpolate_pupil" title="Permalink to this definition">¶</a></dt>
<dd><p>Use linear interpolation to reconstruct nan values in interp_cols.</p>
<dl class="simple">
<dt>samples<span class="classifier">DataFrame</span></dt><dd><p>Samples containing the data to be interpolated.</p>
</dd>
<dt>interp_cols<span class="classifier">list, optional</span></dt><dd><p>Columns to interpolate. The default is [‘diameter’].</p>
</dd>
</dl>
<dl class="simple">
<dt>samps<span class="classifier">DataFrame</span></dt><dd><p>masked data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.interpolate_zeros">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">interpolate_zeros</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">fields</span><span class="o">=</span><span class="default_value">['diameter']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.interpolate_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace 0s in “samples” with linearly interpolated data.
Parameters
———-
samples : DataFrame</p>
<blockquote>
<div><p>The samples in which you’d like to replace 0s</p>
</div></blockquote>
<dl class="simple">
<dt>interp_cols<span class="classifier">list</span></dt><dd><p>The column names from samples in which you’d like to replace 0s.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.load_annotations">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">load_annotations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_dir</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.load_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads annotations (a.k.a. ‘triggers’, ‘events’, etc.) exported 
from Pupil Player.</p>
<dl class="simple">
<dt>data_dir<span class="classifier">str</span></dt><dd><p>Directory where the Pupil Labs ‘annotations’ data exists.</p>
</dd>
</dl>
<dl class="simple">
<dt>events<span class="classifier">DataFrame</span></dt><dd><p>Pandas DataFrame containing events.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.load_blinks">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">load_blinks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_dir</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.load_blinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads ‘blinks’ data exported from Pupil Player.</p>
<dl class="simple">
<dt>data_dir<span class="classifier">str</span></dt><dd><p>Directory where the Pupil Labs ‘blinks’ data exists.</p>
</dd>
</dl>
<dl class="simple">
<dt>blinks<span class="classifier">DataFrame</span></dt><dd><p>Pandas DataFrame containing blink events.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.load_pupil">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">load_pupil</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_dir</span></em>, <em class="sig-param"><span class="n">eye</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'3d c++'</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.load_pupil" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads ‘pupil_positions’ data exported from Pupil Player.</p>
<dl class="simple">
<dt>data_dir<span class="classifier">str</span></dt><dd><p>Directory where the Pupil Labs ‘annotations’ data exists.</p>
</dd>
<dt>eye<span class="classifier">str</span></dt><dd><p>Eye to load. Must be ‘left’ (1), ‘right’ (0), ‘both’ or ‘best’. If 
‘both’, the data are returned in a single DataFrame containing binocular 
data with the right eye joined to the nearest timestamp of the left eye
(in most cases it will be preferable to load each eye separately). If 
‘best’, the eye with the highest average confidence will be loaded. The
default is None.</p>
</dd>
<dt>method<span class="classifier">string, optional</span></dt><dd><p>Whether to load pupil data generated by the 2d or 3d fitting method. 
The default is ‘3d c++’.</p>
</dd>
<dt>cols<span class="classifier">list, optional</span></dt><dd><p>Columns to load from the file, e.g. [‘pupil_timestamp’,’diameter’,
‘diameter_3d’] (check file for options). The default is None 
(loads all columns).</p>
</dd>
</dl>
<dl class="simple">
<dt>samps<span class="classifier">DataFrame</span></dt><dd><p>Pandas DataFrame containing requested samples.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.mask_blinks">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">mask_blinks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">blinks</span></em>, <em class="sig-param"><span class="n">mask_cols</span><span class="o">=</span><span class="default_value">['diameter']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.mask_blinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets untrustworthy pupil data to NaN.</p>
<dl class="simple">
<dt>samples<span class="classifier">DataFrame</span></dt><dd><p>Must contain at least ‘pupil_timestamp’ and ‘diameter’ columns</p>
</dd>
<dt>blinks<span class="classifier">DataFrame</span></dt><dd><p>Must contain ‘start_timestamp’ and ‘end_timestamp’ columns</p>
</dd>
<dt>mask_cols<span class="classifier">list, optional</span></dt><dd><p>Columns to mask. The default is [‘diameter’].</p>
</dd>
</dl>
<dl class="simple">
<dt>samps<span class="classifier">DataFrame</span></dt><dd><p>masked data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.mask_pupil_confidence">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">mask_pupil_confidence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">0.8</span></em>, <em class="sig-param"><span class="n">mask_cols</span><span class="o">=</span><span class="default_value">['diameter']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.mask_pupil_confidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets data in mask_cols to NaN where the corresponding confidence metric is
below threshold. Pupil Labs reccommend a threshold of 0.8. Helpful for
dealing with blinks.</p>
<dl class="simple">
<dt>samples<span class="classifier">DataFrame</span></dt><dd><p>Samples containing the data to be masked.</p>
</dd>
<dt>threshold<span class="classifier">float, optional</span></dt><dd><p>Confidence threshold for masking. The default is 0.8.</p>
</dd>
<dt>mask_cols<span class="classifier">list, optional</span></dt><dd><p>Columns to mask. The default is [‘diameter’].</p>
</dd>
</dl>
<dl class="simple">
<dt>samps<span class="classifier">DataFrame</span></dt><dd><p>masked data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.mask_pupil_first_derivative">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">mask_pupil_first_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">3.0</span></em>, <em class="sig-param"><span class="n">mask_cols</span><span class="o">=</span><span class="default_value">['diameter']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.mask_pupil_first_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a statistical criterion on the first derivative of pupil data to mask 
poor quality data. Helpful for dealing with blinks.</p>
<dl class="simple">
<dt>samples<span class="classifier">DataFrame</span></dt><dd><p>Samples containing the data to be masked.</p>
</dd>
<dt>threshold<span class="classifier">float, optional</span></dt><dd><p>Number of standard deviations from the mean of the first derivative 
to use as the threshold for masking. The default is 3.0.</p>
</dd>
<dt>mask_cols<span class="classifier">list, optional</span></dt><dd><p>Columns to mask. The default is [‘diameter’].</p>
</dd>
</dl>
<dl class="simple">
<dt>samps<span class="classifier">DataFrame</span></dt><dd><p>masked data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.mask_zeros">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">mask_zeros</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">mask_cols</span><span class="o">=</span><span class="default_value">['diameter']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.mask_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets any 0 values in columns in mask_cols to NaN.</p>
<dl class="simple">
<dt>samples<span class="classifier">DataFrame</span></dt><dd><p>The samples to search for 0 values.</p>
</dd>
<dt>mask_fields (list of strings)</dt><dd><p>The columns to search for 0 values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.new_subject">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">new_subject</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rec_dir</span></em>, <em class="sig-param"><span class="n">export</span><span class="o">=</span><span class="default_value">'000'</span></em>, <em class="sig-param"><span class="n">out_dir_nm</span><span class="o">=</span><span class="default_value">'pyplr_analysis'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.new_subject" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin data analysis for a new subject.</p>
<dl class="simple">
<dt>rec_dir<span class="classifier">str</span></dt><dd><p>Full path to a Pupil Labs recording directory for a given subject.</p>
</dd>
<dt>export<span class="classifier">str</span></dt><dd><p>The export folder in which to look for files (in case of multiple 
exports). The default is ‘000’.</p>
</dd>
<dt>out_dir_nm<span class="classifier">str, optional</span></dt><dd><p>Name for the folder where output will be saved. The default is
‘pyplr_analysis’.</p>
</dd>
</dl>
<dl class="simple">
<dt>FileNotFoundError</dt><dd><p>If subjdir does not exist.</p>
</dd>
</dl>
<dl class="simple">
<dt>s<span class="classifier">dict</span></dt><dd><p>Dictionary of subject information.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.print_file_structure">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">print_file_structure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rec_dir</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.print_file_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the file structure of a recording directory.</p>
<p>None.</p>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.pupil_confidence_filter">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">pupil_confidence_filter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">0.8</span></em>, <em class="sig-param"><span class="n">mask_cols</span><span class="o">=</span><span class="default_value">['diameter']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.pupil_confidence_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets data in mask_cols to NaN where the corresponding confidence metric is
below threshold. Pupil Labs reccommend a threshold of .8. An alterntive
to interpolating blinks.</p>
<dl class="simple">
<dt>samples<span class="classifier">DataFrame</span></dt><dd><p>The samples from which to pull indices.</p>
</dd>
<dt>threshold<span class="classifier">float, optional</span></dt><dd><p>Threshold to use for filtering by confidence. The default is .8.</p>
</dd>
<dt>mask_cols<span class="classifier">list, optional</span></dt><dd><p>Columns to mask. The default is [‘diameter’].</p>
</dd>
</dl>
<dl class="simple">
<dt>samps<span class="classifier">DataFrame</span></dt><dd><p>masked data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.reject_bad_trials">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">reject_bad_trials</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ranges</span></em>, <em class="sig-param"><span class="n">interp_thresh</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">drop</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.reject_bad_trials" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop or markup trials which exceed a threshold of interpolated data.</p>
<dl class="simple">
<dt>ranges<span class="classifier">DataFrame</span></dt><dd><p>Extracted event ranges with hierarchical pd.MultiIndex.</p>
</dd>
<dt>interp_thresh<span class="classifier">int, optional</span></dt><dd><p>Percentage of interpolated data permitted before trials are marked for
rejection / dropped. The default is 20.</p>
</dd>
<dt>drop<span class="classifier">bool, optional</span></dt><dd><p>Whether to drop the trials from the ranges. The default is False.</p>
</dd>
</dl>
<dl class="simple">
<dt>ranges<span class="classifier">DataFrame</span></dt><dd><p>Same as ranges but with a column identifying trials marked for
rejection (drop = False) or with those trials dropped from the 
DataFrame (drop = True).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyplr.pipeline.savgol_series">
<code class="sig-prename descclassname">pyplr.pipeline.</code><code class="sig-name descname">savgol_series</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">fields</span><span class="o">=</span><span class="default_value">['diameter']</span></em>, <em class="sig-param"><span class="n">window_length</span><span class="o">=</span><span class="default_value">51</span></em>, <em class="sig-param"><span class="n">filt_order</span><span class="o">=</span><span class="default_value">7</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyplr.pipeline.savgol_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a savitsky-golay filter to the given fields
See documentation on scipys savgol_filter method FMI.</p>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">PyPlr</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Example Protocols</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pyplr-pupil">pyplr.pupil</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyplr-stlab">pyplr.stlab</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyplr-cie">pyplr.CIE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyplr-plr">pyplr.plr</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyplr-oceanops">pyplr.oceanops</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyplr-pipeline">pyplr.pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="developers.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">To Do…</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="examples.html" title="previous chapter">Example Protocols</a></li>
      <li>Next: <a href="developers.html" title="next chapter">Developers</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Joel T. Martin and Manuel Spitschan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>